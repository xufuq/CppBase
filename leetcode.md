# 数组
## 704 done
修改头尾下标时，需要+1-1，否则陷入死循环
## 27 done
注意边界条件，要自己会写特殊测试用例
修改过的值要丢弃
## 977 done
注意是从两边向中间，还是从中间向两边
## 209 done
注意循环条件的结束
## 59 done
当最后只剩中间一个格子的时候需要特殊处理

# 链表
## 203 done
删除一个节点后，要对紧跟而来的节点继续判断
而不能直接使用
## 707 done
头结点
节点计数
## 206 done
## 24 done
配对完成之后才能交换
## 19 done
快慢指针
## 02.07 done
先让开头对齐，然后再逐个对比
## 142 done
需要计算相交点

# 哈希表
## 242 done
计数
## 349 done
unordered_set
## 202 done
看是否有重复
## 1 done
记录出现过的数字及 对应坐标
## 454 done
两两组合
## 383 done
对字符计数
## 15 done
官方解法：
固定一个正向遍历的，动后面两个
哈希做法：
## 18 done
固定两个，双向遍历，同上
注意去重

# 字符串
## 344 done
双指针
## 541 done
分段进行
## offer05 done
逆向遍历
## 151 done
遍历取出每个单词，一次放入到原始字符串
## offer58 done
逆向遍历
## 28  多看，这里应该是需要用kmp
自己推出来了kmp
## 459 done
同样应用kmp

# 双指针法
## 27
## 344
## offer05
## 151
## 206
## 19
## 0207
## 142
## 15
## 18

# 栈与队列
## 232 done
两个队列交替
## 225 done
两个栈交替
## 20 done
最后注意有没有括号剩下
## 1047 done
用栈来做
## 150 done
## 239 done
用双向队列找区间内最大值
## 347 done
先哈希，再优先级队列

# 二叉树
## 递归遍历和迭代遍历，两种方法做
## 144 done
迭代：用栈来做 中左右
## 94 done
迭代：只压入中、左，右子节点进入下一次循环 左中右
## 145 done
中右左反过来
## 102 done
用空指针做层间间隔符
## 107 done
翻转102
## 199 done
层序遍历每行的最后一个
## 637 层序求平均值，重复
## 429 遍历数组，重复
## 515 重复
## 116 done
层序
## 117 done
## 104 done
## 111 done
## 226 done
层序
## 101 done
找对称位置
## 222 done
减少时间复杂度的做法需要找满二叉树
## 110 done
递归
## 257 done
递归
## 100 done
递归，也可用队列逐个判断
## 404 done
递归
## 513 done
层序遍历
## 112 done
深度优先
## 106 done
以后续遍历作为基准
## 654 done
遍历找最大值
## 617 done
全都合并到root1上
## 700 done
左右大小的规律
## 98 中序遍历看大小
## 530 中序遍历做差
## 501 done
计数
## 236 done
递归
## 235 done
搜索树的特点，大小值的判断
## 701 done
## 450 done
要把最下边节点的叶子节点保护好
## 669 done
## 108 done
找中间点
## 538 done
中序遍历

# 回溯算法
## 77 done
适当剪纸
## 216 done
从前到后遍历
## 17 done
构造对应关系
## 39 done 
这个是重点，看看随想录是怎么做情况优化的
## 40 done
排序，去重
## 131 done
找与当前字母相同的字母，只有这样才有可能出现回文串
## 93 done
注意限制条件
## 78 done
每一步的结果都要保存
## 90 done
排序，去重
## 491 done
哈希去重
## 46 done
## 47 done
排序去重，不用哈希去重
## 322 done 
**可以从动态规划的角度来做，动态规划专栏再做**
## 51 done
记录轨迹
## 37 done
适当的返回时机

# 贪心算法
## 455 done
需要先排序，再计数
## 376 not done  **贪心,动态规划再做一次**
贪心和动态规划两种方法
贪心其实就是找峰值，找极值点
## 53 done
分段求和，和小于0则舍弃
## 122 done
只计算盈利
## 55 done
找最大覆盖区间
## 45 done
分步找每步新增加的覆盖区间
## 1005 done
负数取反
## 134 done
先判断是否能走完，再找起点
## 135 done
双向便利
## 860 done
统计数量
## 406 done
小数大号先拍
## 452 done
排序和记录区间多用了很多计算
## 435 done
去除的时候要看留哪个
## 763 done
统计最后一次出现
## 56 done
尾坐标
## 738 done
每次都判断新的n是否符合条件
## 714 done
## 968 done
用数字做标记

# 动态规划
## 509 done
3个数就可以维护这个代码
## 70 done
同上
## 746 doen
找最小值
## 62 done
只用一维数组就可以实现
## 63 done
起点为障碍的情况需要考虑
## 343 done
## 96 done
## 416 done
把一半设置为背包问题的目标容量
## 1049 done
同上，找到最靠近一半的数量
## 494 /*重点，需要把加减目标和转换成单纯加到某一个数，需要重做*/
## 474 done
可以看做是一个二维背包
## 518 done
可重复利用的遍历顺序
## 377 重复
## 70 重复
## 322 done
要判断指定数字是否可以被合成
## 279 done
## 139 done
动态规划
## 198 done
抢当前和不抢当前房间两种方案
## 213 done
不同时包含首尾元素就可以
## 337 done
递归法
## 121 done
动态规划的思路也是找买入最小，跟当前价格再做比较
跟贪心的思路是一样的
## 122 done
用一个2*2的数组循环利用，减少内存空间
## 123 done
做一个2*4的数组，分别统计两次卖出的受益
## 188 done
继续应用上个题的思路
## 309 done
买入和上一次卖出隔一天就可以
## 300 done
需要逐个对比
## 674 done
只需一个数字维护当前长度即可
## 718 done
让两个数组从当前坐标末尾开始对比
单独一个变量统计最大值
数组统计的是当前坐标下的两个数组，从末尾开始对比所能达到的最大长度
还可以简化为一维数组
## 1143 done
一维数组可以实现
## 1035 done
同样可以简化为一维数组，和上面一样的道理
## 53 done
没有必要用动态规划做
## 392 done
依旧是看最大重复子序列的长度，跟上面的1035是一样的
## 115 done
统计出现的次数，对目标字符串每个位置上出现的次数需要累加
## 583 done
依旧是统计最长公共子序列
## 72 done
同样是动归从前到后，目标值就是最小修改次数，需要先初始化0行和0列
## 647 done
记录每一对坐标是否是回文串
## 516 done
注意内层顺序一定是从大到小，要不然会有访问未初始化数据的风险

# 单调栈
## 739 done
维护一个单调栈
## 496 done
跟上一个题的思路基本一致
多用了一个map用来映射坐标
## 503 done
轮询两次就可以
## 42 done
单调栈
## 84 done
弹出时才计算当前可以达到的面积
从栈顶坐标到当前坐标都是栈顶高度的占领区
当当前小高度弹出栈顶大高度时，小高度对应的坐标要变成最靠前大高度的坐标